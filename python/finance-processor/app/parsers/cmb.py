import re
import logging
import xml.etree.ElementTree as ET
from xml.dom import minidom
from pathlib import Path
from typing import List, Dict, Set
from bs4 import BeautifulSoup
from app.schemas.models import RegexRule, OutputFormat
from app.config import settings

logger = logging.getLogger(__name__)

class CMBStatementParser:
    """招商银行流水解析器"""

    def __init__(self, input_dir: Path, rules: List[RegexRule], output_format: OutputFormat):
        self.input_dir = input_dir
        self.rules = rules
        self.output_format = output_format

        self.account_name = "Unknown"
        self.account_number = "Unknown"
        self.beancount_account = None
        self.all_transactions = []
        self.account_prefix = "Assets:Bank:CMB"

    def run(self) -> List[Path]:
        """执行解析并返回生成的文件路径列表"""
        self._parse_all_markdowns()

        generated_files = []

        if self.output_format in [OutputFormat.BEAN, OutputFormat.BOTH]:
            f_bean = self._generate_beancount()
            generated_files.append(f_bean)

        if self.output_format in [OutputFormat.CAMT, OutputFormat.BOTH]:
            f_camt = self._generate_camt053()
            generated_files.append(f_camt)

        return generated_files

    def _parse_all_markdowns(self):
        md_files = sorted(self.input_dir.rglob("doc.md"))
        for f in md_files:
            self._parse_single_md(f)

    def _apply_rules(self, row_text: List[str]) -> Dict:
        tags = set()
        meta = {}

        for rule in self.rules:
            try:
                col_indices = [int(x.strip()) for x in rule.rowNumber.split(',')]
            except ValueError:
                continue

            matched = False
            for col_idx in col_indices:
                if col_idx < len(row_text):
                    if re.search(rule.regex, row_text[col_idx], re.IGNORECASE):
                        matched = True
                        break

            if matched:
                if rule.addTag:
                    for t in rule.addTag.split():
                        tags.add(t)
                if rule.addMeta:
                    try:
                        if ":" in rule.addMeta:
                            k, v = rule.addMeta.split(":", 1)
                            meta[k.strip()] = v.strip().strip('"\'')
                    except Exception:
                        pass
        return {"tags": tags, "meta": meta}

    def _parse_single_md(self, file_path: Path):
        try:
            content = file_path.read_text(encoding='utf-8')
            soup = BeautifulSoup(content, 'html.parser')

            if self.account_name == "Unknown":
                name_match = re.search(r"户名[：:]\s*(\S+)", content)
                if name_match: self.account_name = name_match.group(1).strip()

                acct_match = re.search(r"账号[：:]\s*([0-9a-zA-Z]+)", content)
                if acct_match:
                    self.account_number = acct_match.group(1).strip()
                    self.beancount_account = f"{self.account_prefix}:{self.account_number[-4:]}"

            table = soup.find('table')
            if not table: return

            for row in table.find_all('tr'):
                cells = row.find_all('td')
                if not cells: continue
                row_text = [c.get_text(strip=True) for c in cells]

                if len(row_text) < 6 or "记账日期" in row_text[0] or "Date" in row_text[0]:
                    continue

                date_str = row_text[0]
                if not re.match(r'\d{4}-\d{2}-\d{2}', date_str): continue

                try:
                    amount = float(row_text[2].replace(",", ""))
                    balance = float(row_text[3].replace(",", "")) if len(row_text) > 3 else 0.0
                except ValueError:
                    continue

                abstract = row_text[4]
                counter_party = row_text[5]
                customer_note = row_text[6] if len(row_text) > 6 else ""

                rule_result = self._apply_rules(row_text)

                self.all_transactions.append({
                    'date': date_str,
                    'amount': amount,
                    'balance': balance,
                    'payee': counter_party or "Unknown",
                    'narration': f"{abstract} - {customer_note}",
                    'tags': rule_result['tags'],
                    'meta': rule_result['meta']
                })
        except Exception as e:
            logger.error(f"Parse Markdown Error: {e}")

    def _generate_beancount(self) -> Path:
        self.all_transactions.sort(key=lambda x: x['date'])
        out_path = self.input_dir.parent / "result.bean"

        with open(out_path, 'w', encoding='utf-8') as f:
            f.write(f'; Generated by Finance Processor\n')
            f.write('option "title" "Imported Statement"\n')
            f.write(f'option "operating_currency" "{settings.DEFAULT_CURRENCY}"\n\n')

            main_acct = self.beancount_account or "Assets:Unknown"
            f.write(f'1900-01-01 open {main_acct} {settings.DEFAULT_CURRENCY}\n')
            f.write(f'1900-01-01 open Income:Uncategorized {settings.DEFAULT_CURRENCY}\n')
            f.write(f'1900-01-01 open Expenses:Uncategorized {settings.DEFAULT_CURRENCY}\n\n')

            for tx in self.all_transactions:
                target = "Expenses:Uncategorized" if tx['amount'] < 0 else "Income:Uncategorized"

                tag_str = " ".join(tx['tags'])
                if tag_str: tag_str = " " + tag_str

                f.write(f'{tx["date"]} * "{tx["payee"]}" "{tx["narration"]}"{tag_str}\n')
                for k, v in tx['meta'].items():
                    f.write(f'  {k}: "{v}"\n')

                f.write(f'  {main_acct} {tx["amount"]:.2f} {settings.DEFAULT_CURRENCY}\n')
                f.write(f'  {target}\n\n')

        return out_path

    def _generate_camt053(self) -> Path:
        self.all_transactions.sort(key=lambda x: x['date'])
        out_path = self.input_dir.parent / "result.xml"

        if not self.all_transactions:
            out_path.write_text("<root>No Data</root>")
            return out_path

        ET.register_namespace("", settings.NS_CAMT)
        root = ET.Element(f"{{{settings.NS_CAMT}}}Document")
        stmt = ET.SubElement(ET.SubElement(root, "BkToCstmrStmt"), "Stmt")

        for tx in self.all_transactions:
            ntry = ET.SubElement(stmt, "Ntry")

            amt_val = abs(tx['amount'])
            amt_ele = ET.SubElement(ntry, "Amt", Ccy=settings.DEFAULT_CURRENCY)
            amt_ele.text = f"{amt_val:.2f}"
            ET.SubElement(ntry, "CdtDbtInd").text = "CRDT" if tx['amount'] >= 0 else "DBIT"

            ET.SubElement(ET.SubElement(ntry, "BookgDt"), "Dt").text = tx['date']

            tx_dtls = ET.SubElement(ET.SubElement(ntry, "NtryDtls"), "TxDtls")

            raw_narration = tx['narration']
            extra_info = []
            if tx['tags']:
                extra_info.append(f"Tags: {' '.join(tx['tags'])}")
            if tx['meta']:
                meta_str = ", ".join([f"{k}={v}" for k, v in tx['meta'].items()])
                extra_info.append(f"Meta: {meta_str}")

            full_ustrd = f"{raw_narration} | {' | '.join(extra_info)}" if extra_info else raw_narration

            ET.SubElement(ET.SubElement(tx_dtls, "RmtInf"), "Ustrd").text = full_ustrd

        xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="  ")
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(xml_str)

        return out_path