import re
import logging
import xml.etree.ElementTree as ET
from xml.dom import minidom
from pathlib import Path
from typing import List, Dict, Any, Optional
from abc import ABC, abstractmethod

from app.schemas.models import RegexRule, OutputFormat
from app.config import settings

logger = logging.getLogger(__name__)

class BaseStatementParser(ABC):
    """
    银行流水解析器基类

    子类需要实现 _parse_single_md 方法来提取具体银行格式的数据，
    并填充到 self.all_transactions 列表中。
    """

    def __init__(self, input_dir: Path, rules: List[RegexRule], output_format: OutputFormat):
        self.input_dir = input_dir
        self.rules = rules
        self.output_format = output_format

        # 账户基础信息
        self.account_name = "Unknown"
        self.account_number = "Unknown"
        self.beancount_account = None
        self.account_prefix = "Assets:Bank:Unknown" # 子类应覆盖此值

        # 解析后的标准交易列表
        # 结构: [{'date': str, 'amount': float, 'balance': float, 'payee': str, 'narration': str, 'tags': Set, 'meta': Dict}, ...]
        self.all_transactions: List[Dict[str, Any]] = []

    def run(self) -> List[Path]:
        """执行解析并返回生成的文件路径列表 (模板方法)"""
        self._parse_all_markdowns()

        generated_files = []

        # 按需生成文件
        if self.output_format in [OutputFormat.BEAN, OutputFormat.BOTH]:
            try:
                f_bean = self._generate_beancount()
                generated_files.append(f_bean)
            except Exception as e:
                logger.error(f"Failed to generate Beancount file: {e}")

        if self.output_format in [OutputFormat.CAMT, OutputFormat.BOTH]:
            try:
                f_camt = self._generate_camt053()
                generated_files.append(f_camt)
            except Exception as e:
                logger.error(f"Failed to generate Camt.053 file: {e}")

        return generated_files

    def _parse_all_markdowns(self):
        """遍历目录下所有 doc.md 文件"""
        # 假设 OCR 输出结构是 task_id/ocr_output/page_x_x/doc.md
        md_files = sorted(self.input_dir.rglob("doc.md"))
        if not md_files:
            logger.warning(f"No markdown files found in {self.input_dir}")

        for f in md_files:
            self._parse_single_md(f)

    @abstractmethod
    def _parse_single_md(self, file_path: Path):
        """
        [抽象方法] 解析单个 Markdown 文件
        子类必须实现此方法，并将提取的交易追加到 self.all_transactions
        """
        pass

    def _apply_rules(self, row_text: List[str]) -> Dict[str, Any]:
        """
        应用正则规则，返回 tags 和 meta
        row_text: 表格行的文本列表
        """
        tags = set()
        meta = {}

        for rule in self.rules:
            # 解析列索引配置 "3,4" -> [3, 4]
            try:
                col_indices = [int(x.strip()) for x in rule.rowNumber.split(',')]
            except ValueError:
                continue

            matched = False
            for col_idx in col_indices:
                if col_idx < len(row_text):
                    # 忽略大小写匹配
                    if row_text[col_idx] and re.search(rule.regex, row_text[col_idx], re.IGNORECASE):
                        matched = True
                        break

            if matched:
                if rule.addTag:
                    for t in rule.addTag.split():
                        tags.add(t)
                if rule.addMeta:
                    # 简单解析 "key: value" 格式
                    try:
                        if ":" in rule.addMeta:
                            k, v = rule.addMeta.split(":", 1)
                            meta[k.strip()] = v.strip().strip('"\'')
                    except Exception:
                        pass

        return {"tags": tags, "meta": meta}

    def _generate_beancount(self) -> Path:
        """生成 Beancount 文件 (通用实现)"""
        # 按日期排序
        self.all_transactions.sort(key=lambda x: x['date'])

        # 输出路径: input_dir 的父级目录 (即 task_id 目录)
        out_path = self.input_dir.parent / "result.bean"

        with open(out_path, 'w', encoding='utf-8') as f:
            # 文件头
            f.write(f'; Generated by Finance Processor\n')
            f.write(f'; Account: {self.account_name} ({self.account_number})\n')
            f.write('option "title" "Imported Statement"\n')
            f.write(f'option "operating_currency" "{settings.DEFAULT_CURRENCY}"\n\n')

            # 开户指令
            main_acct = self.beancount_account or "Assets:Unknown"
            f.write(f'1900-01-01 open {main_acct} {settings.DEFAULT_CURRENCY}\n')
            f.write(f'1900-01-01 open Income:Uncategorized {settings.DEFAULT_CURRENCY}\n')
            f.write(f'1900-01-01 open Expenses:Uncategorized {settings.DEFAULT_CURRENCY}\n\n')

            # 交易记录
            for tx in self.all_transactions:
                # 确定借贷方向
                target = "Expenses:Uncategorized" if tx['amount'] < 0 else "Income:Uncategorized"

                # 格式化 Tags
                tag_str = " ".join(tx['tags'])
                if tag_str: tag_str = " " + tag_str

                # 第一行: 日期 * "收款人" "摘要" #标签
                f.write(f'{tx["date"]} * "{tx["payee"]}" "{tx["narration"]}"{tag_str}\n')

                # 元数据
                for k, v in tx['meta'].items():
                    f.write(f'  {k}: "{v}"\n')

                # 主账户金额
                f.write(f'  {main_acct} {tx["amount"]:.2f} {settings.DEFAULT_CURRENCY}\n')
                # 对方账户 (让 Beancount 自动计算金额)
                f.write(f'  {target}\n\n')

        return out_path

    def _generate_camt053(self) -> Path:
        """生成 Camt.053 XML 文件 (通用实现)"""
        self.all_transactions.sort(key=lambda x: x['date'])
        out_path = self.input_dir.parent / "result.xml"

        if not self.all_transactions:
            out_path.write_text("<root>No Data</root>", encoding='utf-8')
            return out_path

        # XML 初始化
        ET.register_namespace("", settings.NS_CAMT)
        root = ET.Element(f"{{{settings.NS_CAMT}}}Document")

        # 结构: BkToCstmrStmt -> Stmt
        bk_to_cstmr = ET.SubElement(root, "BkToCstmrStmt")
        stmt = ET.SubElement(bk_to_cstmr, "Stmt")

        # 填充交易
        for tx in self.all_transactions:
            ntry = ET.SubElement(stmt, "Ntry")

            # 金额 Amount
            amt_val = abs(tx['amount'])
            amt_ele = ET.SubElement(ntry, "Amt", Ccy=settings.DEFAULT_CURRENCY)
            amt_ele.text = f"{amt_val:.2f}"

            # 借贷标识 Credit/Debit
            ET.SubElement(ntry, "CdtDbtInd").text = "CRDT" if tx['amount'] >= 0 else "DBIT"

            # 日期 Booking Date
            bk_dt = ET.SubElement(ntry, "BookgDt")
            ET.SubElement(bk_dt, "Dt").text = tx['date']

            # 交易详情 Entry Details
            ntry_dtls = ET.SubElement(ntry, "NtryDtls")
            tx_dtls = ET.SubElement(ntry_dtls, "TxDtls")

            # 摘要与标签 (放入 Unstructured Remittance Information)
            raw_narration = tx['narration']
            extra_info = []
            if tx['tags']:
                extra_info.append(f"Tags: {' '.join(tx['tags'])}")
            if tx['meta']:
                meta_str = ", ".join([f"{k}={v}" for k, v in tx['meta'].items()])
                extra_info.append(f"Meta: {meta_str}")

            full_ustrd = f"{raw_narration} | {' | '.join(extra_info)}" if extra_info else raw_narration

            rmt_inf = ET.SubElement(tx_dtls, "RmtInf")
            ET.SubElement(rmt_inf, "Ustrd").text = full_ustrd

        # 格式化输出
        xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="  ")
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(xml_str)

        return out_path